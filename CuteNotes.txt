On Intel Documents:
-------------------

* Although the newer intel documents are much more sexy and detailed, the
  original i386 one describes the concepts in a much more bottom-up,
  undergraduate-book like, no forward-references way.

* Somehow the new intel documents beginning from the 1997 i686 document
  assumes some x86 familarity that wasn't obviously assumed in the original
  document.

* For an example, the 'alignment' topic is throughly explained in
  the i386 manual, what is it and why is it important to performance,
  and how the processor act if given a misaligned address, *before* ever
  using the words '16bit-aligned' and '32bit-aligned'.

  The new intel documents assume you know subtle topics as above and
  talks about critical issues related to their understandings freely
  *before* they become throughly discussed. Only at i686 chapter 5
  alignment is throughly described although several critical alignment
  related topics have already been discussed.

* Case 2: on why we should disable interrupts while switching to protected
  mode?

  New Intel document: Software must guarantee that no exceptions or interrupts
  are generated during the mode switching operation.

  Original 386 document: ``The IDTR may be loaded in either real-address or
  protected mode. However, the format of the interrupt table for protected mode
  is different than that for real-address mode. It is not possible to change to
  protected mode and change interrupt table formats at the same time; therefore,
  it is inevitable that, if IDTR selects an interrupt table, it will have the
  wrong format at some time. An interrupt or exception that occurs at this time
  will have unpredictable results. To avoid this unpredictability, interrupts
  should remain disabled until interrupt handlers are in place and a valid IDT
  has been created in protected mode.''

* Case 3: on why should we long jump after switching to protected mode?

  New intel document: ``The JMP or CALL instruction immediately after the MOV
  CR0 instruction changes the flow of execution and serializes the processor.''

  Original 386 document: ``Immediately after setting the PE flag, the
  initialization code must flush the processor's instruction prefetch queue by
  executing a JMP instruction. The 80386 fetches and decodes instructions and
  addresses before they are used; however, after a change into protected mode,
  the prefetched instruction information (which pertains to real-address mode)
  is no longer valid. A JMP forces the processor to discard the invalid
  information.''

  This is a recurring pattern.

* What's IA-32e in new Intel documents?
  Intel has really messed up the namings of their 64bit processors. The
  most logical choice I think was IA-64, but unfortunately that was taken
  by the big flop in processor's history: the Itanium. When Intel waked
  up and created their first amd64 compatible processor, they named it EMT64.
  
  Now intel in its new official documents call the x86_64 architecture
  "intel 64" and call those processor's 64bit mode IA-32e.


On Data Alignment:
------------------

* Note: In x86 speak, word = 2bytes/16bits, double word = 4bytes/32bits

* Each byte within a word has its own address, and the smaller of the
  addresses represent the address of the whole word.

* Each byte within the double word has its own address. The smallest of the byte
  addresses is the address of the double word.

* ``Note that words need not be aligned at even-numbered addresses and
  doublewords need not be aligned at addresses evenly divisible by four.
  This allows maximum flexibility in data structures (e.g., records containing
  mixed byte, word, and doubleword items) and efficiency in memory
  utilization.

  ## When used in a configuration with a 32-bit bus, actual transfers of
    data between processor and memory take place in units of doublewords (4bytes)
  beginning at addresses evenly divisible by four ##

  However, the processor converts requests for misaligned words or doublewords
  into the appropriate sequences of requests acceptable to the memory interface.
  ## Such misaligned data transfers reduce performance by requiring extra memory
  cycles. For maximum performance, data structures (including stacks) should
  be designed in such a way that, whenever possible, word operands are aligned
  at even addresses and doubleword operands are aligned at addresses evenly
  divisible by four. ##

  Due to instruction prefetching and queuing within the CPU, there is no
  requirement for instructions to be aligned on word or doubleword boundaries.
  However, a slight increase in speed results if the target addresses of control
  transfers are evenly divisible by four.''
  	    	       		    	   -- Intel 386 Reference Manual

* ``The reason for this is that the processor requires two memory accesses to
  make an unaligned memory access; whereas, aligned accesses require only one
  memory access. A word or doubleword operand that crosses a 4-byte boundary
  or a quadword operand that crosses an 8-byte boundary is considered unaligned
  and requires two separate memory bus cycles to access it; a word that starts
  on an odd address but does not cross a word boundary is considered aligned
  and can still be accessed in one bus cycle.''
      	  	   	       	       	   -- Intel 686 Reference Manual

* x86 4KB page aligned addresses:

  Decimal:
  10 ^ 0 = 1
  10 ^ 1 = 10
  10 ^ 2 = 100
  10 ^ 3 = 1000
  ...

  Binary:
  2  ^ 0 = 1
  2  ^ 1 = 10
  2  ^ 2 = 100
  ...
  2  ^ 10 = 10000000000 = 1024 = 1KB
  2  ^ 12 = 1000000000000 = 2^2 * 1KB = 4KB (x86 Page size/aligned-address)
  ...

* Common alignments offsets:

  1byte alignment = 2 ^ 0  -- any x86 RAM address

  2byte alignment = 2 ^ 1 (0b10) -- 16bit aligned address
  = any address divisable by 2
  = 0x0, 0x2, 0x4, 0x6, 0x8, ..., 0xa, 0xc, 0xe, 0x10, 0x12, ...
  
  4byte alignment = 2 ^ 2 (0b100) -- 32bit aligned address
  = any address divisable by 4
  = 0x0, 0x4, 0x8, 0xc, 0x10, 0x14, 0x18, 0x1c, 0x20, ...

  8byte alignment = 2 ^ 3 (0b1000) - GDT cell index/size
  = any address divisable by 8
  = 0x0, 0x8, 0x10, 0x18, 0x20, ...
     |    |    |
   null  %cs  %ds

  16byte alignment = 2 ^ 4 (0b10000) - GDT table recommended alignment
  = any address divisable by 16
  = 0x0, 0x10, 0x20, 0x30, 0x40, ..., 0xf0, 0x100, 0x110, 0x120, ...

* Useful numbers:

  0x100   = 256 bytes
  0x200   = 512 bytes  (bootsector size)
  0x400   = 1KB
  0x1000  = 4KB        (x86 normal page size/alignment)
  0x8000  = 32KB
  0xffff  = 64KB -1    (max offset for a real-mode segment)
  0x10000 = 64KB
  0x80000 = 512KB      (our initial kernel size!)

On little-endian byte ordering:
-------------------------------

* From AMD64 documents:

  "The x86 and AMD64 architectures address memory using little-endian
  byte-ordering. Multibyte values are stored with their least-significant byte at
  the lowest byte address, and they are illustrated with their least significant
  byte at the right side. Strings are illustrated in reverse order, because the
  addresses of their bytes increase from right to left."

  Value =

  BYTE-7  BYTE-6  BYTE-5  BYTE-4  BYTE-3  BYTE-2  BYTE-1  BYTE-0

  Actual Mem Layout:

  BYTE-0  BYTE-1  BYTE-2  BYTE-3  BYTE-4  BYTE-5  BYTE-6  BYTE-7
  ^
  |--- Address start here

  For illustrative purposes only - not actual mem layout:

  GREATEST                 DATA STRUCTURE
  ADDRESS
   31              23              15              7             0 <--BIT
  +---------------+---------------+---------------+---------------+   OFFSET
  |    BYTE 7     |    BYTE 6     |    BYTE 5     |    BYTE 4     |4
  |---------------+---------------+---------------+---------------|  SMALLEST
  |    BYTE 3          BYTE 2          BYTE 1          BYTE 0     |0 ADDRESS
  +---------------+---------------+---------------+---------------+^
                                                                   |
                                             Address start here ---|

* Classical little-endian ordering:

  .long  0x00cf9200 = 00 92 CF 00
                      ^
                      |--- Address start
  =

  +---------------+---------------+---------------+---------------+
  |      00       |      CF       |      92       |       00      |
  +---------------+---------------+---------------+---------------+^
                                                  Address start ---|

* GAS concatenation:

  .long  0x00cf9200, 0x0000ffff  != .quad 0x00cf92000000ffff

  .long  0x00cf9200, 0x0000ffff
  =
  .long  0x00cf9200
  .long  0x0000ffff
  =
  .quad  0x0000ffff00cf9200
  =
  (actual layout in memory)
  00 92 CF 00  FF FF 00 00
  ^
  |--- Address start
  =
  (for illustrative purposes only - _NOT_ actual mem layout)
  +---------------+---------------+---------------+---------------+
  |      00       |      00       |      FF       |       FF      |
  |---------------+---------------+---------------+---------------|
  |      00       |      CF       |      92       |       00      |
  +---------------+---------------+---------------+---------------+^
                                                  Address start ---|
  BUT:

  .long  0x0000ffff
  .long  0x00cf9200
  =
  .quad  0x00cf92000000ffff
  =
  (for illustrative purposes only - _NOT_ actual mem layout)
  +---------------+---------------+---------------+---------------+
  |      00       |      CF       |       92      |      00       |4
  |---------------+---------------+---------------+---------------|
  |      00       |      00       |       FF      |      FF       |
  +---------------+---------------+---------------+---------------+^
                                                  Address start ---|
  =
  (actual layout in memory)
  FF FF 00 00  00 92 CF 00
  ^
  |--- Address start

* So:

  test.S:                           |  print.c:
                                    |
  .global test                      |  #include <stdint.h>
  test:                             |  extern uint64_t test;
        .quad 0x00cf92000000ffff    |  int main(void) { printf("test = 0x%x\n", test); }

  output: test = 0x0000ffff
  as the 64-bit value is presented as: (address-start) FF FF 00 00 00 92 ... (address-end)

* The String "WXYZ" is represented in memory as:

  'W' 'X' 'Y' 'Z'
  ^
  |--Address start

  And in the usual memory diagrams:

  +---------------+---------------+---------------+---------------+
  |      'Z'      |      'Y'      |      'X'      |      'W'      |
  +---------------+---------------+---------------+---------------+^
                                                  Address start ---|

On Real Mode:
-------------

* To achieve maximum backward compatibility, x86 processors starts in the 16bit
  8086-compatible real-mode. The 8086 had a complete 16-bit architecture - 16-bit
  internal registers, 16-bit data bus, and a *20-bit* external address bus (1 MB
  of physical memory).

  Because the 8086 processor had 16-bit index registers and memory pointers,
  it can effectively address *only* up to 64 KB of memory, which wasn't acceptable
  even by that time. 

* So, to address the memory beyond 64 KB (the remaining 20bit 1MB address space)
  with 16bit registers, Intel created a `segmented' memory addressing scheme.

  We want to access 20bit address space, namely 0xfffff at max. The 8086
  processor's registers are only 16bit, namely a max value of 0xffff. To solve
  this issue, the 8086 processor used *two* registers to address physical memory.
  The two registers are a segment described as a base address, and an offset within
  that segment.

  The goal: addressing up to the max 20bit value; 0xfffff:

  f 0 0 0 0     <-- 16bit value (segment base address) hex left shifted once to
      	  	    address the 4 highest order bits in the goal.
            +   <-- A simple adding operation

    f f f f	<-- 16bit value, max offset we can address

    -------

  f f f f f	<-- The goal (max 20bit value we can address)
  
  So physical memory in the 8086 is accessed through a `segment:offset' scheme

  where physical address = (segment * 16) + offset

* Note that the above segment model is very primitive that there are really no
  real `segments' identified by the processor. A *physical* 'segment' is
  basically just a 16-bit aligned physical address address with an offset
  `limit' of 64K enforced by the processor registers limit.

  Example:

  a000:0010 = a010:0000         /* Overlapping 'segments' */
  f000:ffff = ffff:000f         /* Maximum address using different 'segments' */
  40:100    = 50:00             /* Last byte in Bios Data Area */

  It's important to note that a segment register can take any value ranging
  from 0 to 0xffff including the non-16bit-aligned addresses. It's on *physical*
  memory where a segment base address is always 16-bit aligned due to the left
  shift, not the segment register value itself.

  Example of completely valid segment register values and their physical
  addresses:

  Segment register value    |   Segment physical address
  -------------------------------------------------------
          0xffff            |           0xffff0
          0x1abc            |           0x1abc0
          0x4242            |           0x42420
          ...               |           ...
          0xyyyy            |           0xyyyy0, y = /[0-f]/

* Some calculations:

  biggest segment address possible = 0xffff

  biggest offset possible = 0xffff

  biggest *physical* address that can act as a segment address =
    biggest 20-bit address which is 16-byte aligned = 0xffff0
  
* NOTE: There's a huge difference between real-mode `segments' and segments
  provided in 386+ protected-mode processors. The 16bit value in a segmented
  protected-mode logical address is what's called a `segment selector' which
  is basically a pointer to a `segment descriptor' stored in either the GDT or
  the LDT. The segment descriptor includes info like the protected-mode segment
  base, limit, access permissions, present bit, etc.

  On the other hand, the real-mode `segments' are just primitive addresses
  that get hex left shifted in address calculations.

* Note that using this scheme, code segments are limited to a size of 64KB.
  To reach more code, we had to jump to what's called 'far pointers', which
  not only contains an offset relative to current code segment, but also a
  new address for the code segment.

  AT&T syntax for far jumps: `ljmp  $SEGMENT, $OFFSET' where 'segment' and
  'offset' are naturally 16bit values.

  Usage example: after loading the kernel to ram at its chosen segment which
  is usually far away from the mbr code segment, we 'far jump' to this segment
  with offset 0 to execute the loaded kernel code and go beyond the mbr's 512
  bytes size limit. This is the same technique used by GRUB to loads its stages.

* The above terminology is also the root of 386+ protected mode 'far pointer'
  which is a 'logical address' containing a segment selector (16 bit) and an
  offset (32 bit) relative to the segment pointed by the selector.

On accessing fixed disk drivers (hard-disks):
---------------------------------------------

* There's the usual heads, tracks, sectors, and cylinders. 

  Track: when the head is positioned over a point on the fixed disk, ready
  to read or write, the disk platter surface spins underneath it, tracing a
  full circle. This circle is a track. A disk surface contains may tracks.

  Sectors: Fixed disk systems divides each track into short arcs called
  sectors, each sector usually holds 512 bytes. This is the smallest unit
  of storage, as tracks would mean wasting a lot of space for small files.

  Cylinder: all the heads move in and out together, so each head is always
  physically located at the same track number; we can't have one head at
  track 0, and another at 250. Because of this, often the track location of
  the heads is not referred to as a track number but rather as a cylinder
  number.

  Disk size = bytes per sector * sectors per track * number of cylinders *
              number of heads

* BIOS fixed disk services are provided through the INT 13h service
  routine. It programs the hard-disk controller; it never writes directly
  from the processor to the hard-disk drive. The hard-disk controller
  communicates directly between the hard-disk, the processor, and system
  memory.

* To support disks beyoned the 8GB limit enforced by original IBM bios
  design (max of 1024 cylinder, 256 heads, and 63 sectors), new INT13
  bios services were added to bios which offers simple sector addressing
  using a logical zero based sector number (0, 1, 2, ..)

  This addressing scheme is easier than the Cylinder-Head-Sector model
  and is supported in all bios chips post-1995, so we use it exclusively.

  Check the boot sector code for more details.

The 8259A Programmable Interrupt Controller:
--------------------------------------------

* References:
  - The Intel 8259A PIC datasheet.
  - The superb information in "The undocumented PC", chapter 17 - "Interrupt
  control and NMI".

  In subsequent text, and as said by the sheet, IRR = "Interrupt Request
  Register", ISR="In-Service Register", IMR = "Interrupt Mask Register".

* As described by Brendan Trotter (bcos) on #osdev, and the sheet:

  An interrupt request is executed by raising an IR input (low to high) and
  holding it high until it is acknowledged (Edge Triggered Mode). Where
  "acknowledged" means doing so by the PIC chip, not by the CPU/OS . Also, in
  this case "acknowledges" just means that it recognises it and sets the
  corresponding flag in the IRR

  Basically, when an interrupt is received the PIC sets the corresponding flag in
  the IRR. When the PIC sends the IRQ to the CPU it clears the flag in the IRR
  and sets the flag in the ISR. And when the CPU sends EOI the PIC clears the
  flag in the ISR. The processor sends an EOI through the the INTA pin.

  If the PIC sends a high priority IRQ to the CPU and is waiting for EOI when a
  low priority IRQ occurs, then the PIC must remember that the low priority IRQ
  occured (so that it can tell the CPU about it when the CPU is finished with the
  high priority IRQ), by setting its IRR bit.

  The 8259 cannot be used with level interrupts. This is because when
  an interrupt line goes true, it is latched internally in the IRR.

* Spuruious interrupts:

  As said by the sheet: "If no interrupt request is present at step 4 of either
  sequence (i.e., the request was too short in duration), the 8259A will issue an
  interrupt level 7. Both the vectoring bytes and the CAS lines will look like an
  interrupt number 7 was requested."

  And as said in undoc pc: "Although a noise glitch should never occur, a poor
  bus design or badly glitch will trigger an invalid interrupt. If the glitch
  occurs on IRQ 0 to IRQ7, interrupt F (which is mapped to IRQ 7) will be
  called. The service handler for interrupt Fh and 77H (assuming the PIC wasn't
  re-mapped to more sane vector-numbers) should read the in-service register to
  confirm that a real interrupt occurred. An invalid interrupt has In-Service bit
  7 cleared, and a valid interrupt has valid bit 7 set.

* So why should the PIC bother sending the CPU a spurious 7 IRQ? it could've just
  ignored the noise glitch source. The problem is that it might have told the CPU
  it's about to get an interrupt, and if it did (step 1, 2, and 3), it can not
  now decode the interrupt info since the line has been deasserted. Either the
  assert period was too short that the IRQ number was not latched internally, or
  the PIC just recognized it was a noise glitch due to the very short assertion
  period. So it gives the programmed IRQ 7 vector number to the CPU. This avoids
  unccessary communication with the real devices attached to IRQ7.

* Take care that, as said by linux kernel comments, the two spurious IRQs 7 and
  15 usually resulting from the 8259A-1|2 PICs do occur even if all the IRQs are
  masked (IMR = 0xff).

* An example of an interrupt (refs: undoc pc + intel sheet):

  1- The adapter card requests service, by driving the hardware IRQ line 5 from
     low to high

  2- The IRQ 5 line is connected to the PIC. The edge-triggered request is
     recorded in the controllers Interrupt-Request Register (IRR). In this case,
     the IRR bit 5 is set.

  3- The PIC first checks if the Interrupt Mask Register (IMR) to see if IRQ5 is
     allowed (not masked, IMR bit 5 = 0). Assuming that bit clear, the PIC moves
     to the next step.

  4- Using its priority resolver uint, the conntroller checks if any higher
     priority interrupts are active or in progress. If so, no further action is
     done till all higher priority irqs are serviced.

  5- Once all higher irqs are serviced, the controller flags the CPU over the
     dedicated INT hardware line leading to the CPU.

  6- If the CPU has hardware interrupts enabled, the CPU returns an interrupt
     acknowledgment to the PIC using the INTA pin.

  7- Directly after receiving a pulse from the INTA pin, the relevant In-Service
     register bit (bit 5) is set, and the corresponding IRR bit is reset.

  8- The processor sends another INTA pulse. During this pulse, the PIC sends
     a programmed 8-bit pointer back to the CPU, according the raised IRQ. In
     the default bios programmed PIC case, the pic will return the interrupt
     value 0x0D for IRQ5. 

  9- In an instruction boundary, the cpu interrupts the current process and
     jumps to the code address specified in the IDT entry 0xD. For x86-64 cpus,
     entry 0xD = IDT base (specified through lidt) + 0xD * 16.

 10- One of the key aspects of the interrupt handler specified in the IDT entry
     must make is to remove the interrupt request made by the adapter. The line
     maybe shared, and several ISRs got executed, where they determine first if
     they are servicing the right device using the "interrupt pending" register
     found in PCI devices, etc.

 11- At the end of the interrupt handler, the handler sends the value 0x20 to
     the PIC command port to indicate an End-of-Interrupt (EOI). The EOI command
     clears the IRQ5 bit in the In-Service Regisger.(*) The case is different in
     case of Automatic EOI (AEOI) mode, and is described later.

 12- By clearing the IRQ5 bit in the ISR, the chip is now ready to accept another
     interrupt from IRQ5 or any lower priority interrupt. This completes the
     interrupt cycle.

* On x86 SMP initialization sequence:
-------------------------------------

* References:
  - Intel MP specification v1.4, Appendix B - Operating System Programming
  Guideleins.
  - Intel Software Dev. Manual vol3A, Chapter 8, 8.4 - Multiple-Processor (MP)
  initialization.
  - Intel Software Dev. Manual vol3B, Appendix C - MP Initialization for P6
  Family Processors.

* Generally, there're two base x86 MP initialization sequences. One for the
  processors with the external APIC, and a second for processors with internal
  APIC (P6+ x86 processors).

  We won't bother ourself with the processors with external APICs (80486 and
  early Pentiums) since we're only targetting long mode.

  All long mode capable processors contains an integrated apic and comply with
  the new Intel MP bootup sequence, where no FIPI or BIPI are needed.

  On this new sequence, the INIT IPI on AP cores let them wait for the SIPI to
  get their starting execution vector instead of _unconditionally_ executing the
  BIOS init code. This avoids the ugly dependency on AT+ BIOSes hacks like the
  warm-reset vector to let the AP cores start executing from a custom address
  instead of BIOS init code. Search the MP spec for `Warm-reset vector'.

* After system-wide bootup, or reset, the MP initialization protocol is going to
  be executed. In this protocol, the hardware setup the APIC IDs for each logical
  core according to system topology and assign one of the cores as the bootstrap
  core and the others as APs (Application processors/cores).

  The core nominated as the BSC will fetch and begin executing BIOS bootstrap
  code at the reset vector physical address 0xfffffff0.

  The remaining cores (setup as APs) will enter a "wait-for-SIPI" state.

* Afterwars, the BIOS init code builds its ACPI and MP tables and count the
  number of AP cores, and update its tables entries for each new AP core
  found. For the algorithm, check Intel's volume 3A 8.4.4 MP Initialization
  Example.

* At the end, the BIOS puts each AP core to halted state with interrupts
  disabled. By the nature of the halted state with interrupts disabled, only
  INIT, #NMI, #SMI are able to start the cores again.

  IMPORTANT: The MP protocol will be executed only after a power-up or RESET. If
  the MP protocol has been completed and a BSP has been chosen, subsequent INITs
  (either to a specific processor or system wide) do not cause the MP protocol to
  be repeated. Instead, each processor examines its BSP flag (in the APIC_BASE
  MSR) to determine whether it should execute the BIOS boot-strap code (if it is
  the BSP) or enter a wait-for-SIPI state (if it is an AP).

  So any INIT to any of the AP cores by the OS boot code will let it enter a
  'wait-for-SIPI' state to be able to get its start execution vector.

* Note that the cores get started with all its states uninitialized. We have
  to update each core from real to long mode, and update its MMU and other
  system tables to match the bootstrap.

  Kernels usually call this part the SMP `trampoline', since it let the cores
  jump from its raw uninitialized state to a state similar to the bootstrap's
  one.

